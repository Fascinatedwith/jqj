(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-d60d0164"],{"08a5":function(n,e,t){"use strict";t("ac62")},"0bf1":function(n,e,t){"use strict";t.r(e);var r=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"content",class:{contentTheme:n.theme}},[t("div",{staticClass:"synopsis"},[n._v("简介")]),t("div",{staticClass:"synopsisBox"},[n._v(" TypeScript(简称: TS)是JavaScript的超集 (JS有的 TS 都有) ")]),t("div",{staticClass:"br"}),t("h3",{staticStyle:{margin:"20px 0"}},[n._v("1. TypeScript常用类型")]),n._m(0),t("h3",{staticStyle:{margin:"20px 0"}},[n._v("2. TypeScript高级类型")]),n._m(1)])},s=[function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("pre",{staticClass:"pre"},[n._v("    "),t("code",{staticClass:"code"},[n._v("\n      /* 原始类型  */\n      let age: number = 18  // 数字型\n      let age: string = '18'  // 字符串型\n      let age: boolean = false  // 布尔型\n      let age: null = null  // null\n      let age: undefined = undefined // undefined\n      let age: symbol = Symbol() // symbol\n\n      /* 数组类型  */\n      let age: number[] = [1,2,3]  // 数值数组\n      let age: string[] = ['1','2','3'] // 字符串数组\n      // 另一种写法   let age: Array< string> = ['1','2','3']\n\n      /* 联合类型  */  由两个或多个类型组成的\n      let age: (number | string)[] = [1,'2',3]  // 数字和字符串数组\n      let age: boolean[] = [true,false] // 布尔数组\n\n      /* 元组  */  是另一种类型的数组，确切的知道包含多少个元素及对应类型\n      let arr:[number,number] = [1,2]\n\n      /* 对象类型  */  描述对象的结构，属性类型之间用 ；分隔\n      let obj:{name: string; age: number; sayHi: void} = {\n        name:'a',\n        age:18,\n        sayHi(){ }\n      }\n\n      /* 函数类型  */   实际上是给函数的参数和返回值指定类型\n      // 指定参数和返回值类型\n      function add(num1:number,num2:number): number {\n        return num1 + num2\n      }\n\n      /* void类型  */   如果函数没有返回值return，那么返回值类型为 void\n      function add(name:string): void {\n        console.log('hello')\n      }\n\n      /* 可选参数  */  参数可以传也可以不传, 参数名称后添加 ?\n      function add(name?:string): void {\n        console.log('hello')\n      }\n\n      /* 为任意类型起别名，简化该类型的使用 两种方式  */\n\n      /* type(类型别名)  */\n      type CustomArray = (number | string)[]  // 创建别名，可以是任意变量名\n      let age: CustomArray = [1,'2',3]  // 使用别名作为类型注解\n\n      /* interface(接口)  */\n      type CustomArray = (number | string)[]  // 创建别名，可以是任意变量名\n      let age: CustomArray = [1,'2',3]  // 使用别名作为类型注解\n\n      /* 类型继承 extends  */\n      interface P2 {x:number; y:number}\n      // P3继承P2的类型并添加自己的类型\n      interface P3 extends P2 {z:number}\n      // P3= {x:number; y:number; z:number}\n\n      /* 类型断言 as  */\n      const aLink = document.getElementById('link') as HTMLAnchorElement\n      // 通过类型断言 alink的类型变得更加具体，这样就可以访问a标签特有的属性和方法了\n\n      /* 字面量类型  */\n      let str1 = 'hello'    // 他的类型为 字符串\n      const str2 = 'hello'   // 他的类型为 hello 就是一个字面量类型\n      // 因为 str2 是一个常量，值不能变化只能是hello，所以它的类型为 hello\n      // 除字符串外，任意js字面量（比如对象，数字等）都可以作为类型使用\n\n      /* 枚举类型 enum  */  枚举：定义一组命名常量，描述一个值，该值可以是这些命名常量中的一个  枚举中的值以大写字母开头，多个值以逗号分割\n      enum Direction {Up, Down, Left, Right}\n      function changeDirection(direction: Direction) {\n        console.log(direction)\n      }\n      // 访问枚举成员 Direction.Up\n      // 调用\n      changeDirection(Direction.Up)\n\n      /* 数字枚举  */\n      // 枚举成员是有值的，默认从0开始自增的数值\n      // 也可以给枚举中成员初始化值\n      enum Direction {Up=10, Down, Left, Right}\n      // 如此Down=11 以此类推自增\n\n      /* 字符串枚举  */\n      enum Direction {Up='up', Down='Down'}\n      // 字符串枚举是没有自增长行为的，并且每个成员必须都有值\n\n      /* any类型  */\n      let obj:any = {x:0}\n\n      /* typeof运算符  */\n      let p = {x:1, y:2}\n      // 两种写法意思相同\n      function format(point:{x:number; y: number}) {}\n      function format(point: typeof p) {} // 就会把p的类型引用下来\n    ")]),n._v("\n  ")])},function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("pre",{staticClass:"pre"},[n._v("    "),t("code",{staticClass:"code"},[n._v("\n      /* class类  */  不仅提供了js中class语法的功能，也作为一种类型存在\n      class Person {}  // 创建一个类\n      const p = new Person()   // 创建实例对象\n\n      /* class类的基本使用  */\n      class Person { // 创建一个类\n        age:number\n        gender='男'\n      }\n      const p = new Person()   // 创建实例对象\n      p.age   // 使用\n\n      /* class类的构造函数 constructor  */\n      class Person { // 创建一个类\n        age:number\n        gender:string\n        // 构造函数\n        constructor(age: number, gender: string) {\n          this.age=age\n          this.gender=gender\n        }\n      }\n      const p = new Person(18, '男')\n\n      /* class类的继承  */  extends (继承父类)  implements （实现接口）\n      // extends\n      class Animal {\n        move() { log('1') }\n      }\n      class Dog extends Animal {  // 继承父类里所有属性和方法\n        bark() { log('2') }\n      }\n      const d = new Dog()\n      dog.move()  // 可以访问父类里的方法\n\n      // implements\n      class Animal {\n        move(): void\n      }\n      class Dog implements Animal {\n        // 里面必须提供Animal里的所有属性和方法，\n        move() {\n          log('2')\n        }\n      }\n\n      /* class类的可见性修饰符  */\n      /* public (公有的)  */  表示公开的，可以被任何地方访问，默认可见性可省略\n      class Animal {\n        public move(){\n          log(1)\n        }\n      }\n      const a = new Animal()\n      a.move()  // 1\n\n      /* protected (受保护的)  */  表示受保护的，仅对其声明所在类和子类中可见，实例对象不可见 可以在子类中通过this访问受保护的\n      class Animal {\n        protected move(){ log(1) }\n        run(){\n          this.move() // 在类中通过this调用\n        }\n      }\n      const a = new Animal()\n      a.move()  // 报错\n\n      class Dog extends Animal {\n        bark(){\n          this.move() // 在子类中通过this调用\n        }\n      }\n      const d = new Dog()\n      d.bark()  // 1\n\n      /* private (私有的)  */   表示私有的，只在当前类中可见\n      class Animal {\n        private move(){ log(1) }\n        run(){\n          this.move() // 在当前类的其他方法中通过this调用\n        }\n      }\n\n      /* class类的只读修饰符 readonly  */  表示只读，用来防止在构造函数之外对属性进行赋值\n      class Animal {\n        // 只读属性\n        readonly age:number = 18 // 需指定类型 否则无法赋值\n        constructor(age:number){\n          this.age= age  // 只能在构造函数中赋值\n        }\n        run() {\n          this.age= 20  // 方法中赋值 报错\n        }\n      }\n      const a = new Animal(20)\n\n      /* 类型兼容性  */\n\n      /* 对象之间的类型兼容性  */  对于对象类型来说，成员多的可以赋值给成员少的\n      // Point兼容Point2D\n      class Point { x:number; y:number }\n      class Point2D { x:number; y:number; z:number }\n      const p:Point = new Point2D() // 可以\n      const p:Point2D = new Point() // 报错\n\n      /* 接口之间的类型兼容性  */  class 和 interface 都是对象，所以他俩也可以兼容\n      interface Point { x:number; y:number; }\n      interface Point2D { x:number; y:number; }\n      class Point3D { x:number; y:number; z:number }\n      let p1:Point\n      let p2:Point2D\n      p2=p1\n      p1=p2\n      let p3:Point2D = new Point3D() // 也可以兼容\n\n      /* 函数之间的类型兼容性  */  函数兼容比较复杂，需要考虑 参数个数、参数类型、返回值类型\n      /* 参数个数  */  参数少的可以赋值给参数多的\n      type F1 = (a:number) => void\n      type F2 = (a:number,b:number) => void\n      let f1:F1\n      let f2:F2\n      f2 = f1 // 可以\n\n      /* 参数类型  */  相同位置的参数类型要相同（原始类型）或兼容（对象类型）\n      type F1 = (a:number) => void\n      type F2 = (a:number) => void\n      let f1:F1\n      let f2:F2\n      f2 = f1 // 可以\n      f1 = f2 // 可以\n\n      interface Ponint2D { x:number; y:number;}\n      interface Ponint3D { x:number; y:number; z:number;}\n      // 技巧 ：将对象拆开，把每个属性个数看做一个个参数\n      type F2 = (a:Ponint2D) => void  // 相当于有2个参数\n      type F3 = (a:Ponint3D) => void  // 相当于有3个参数\n      let f2:F2\n      let f3:F3\n      f2=f3  // 不行\n      f3=f2  // 可以 参数少的可以赋值给参数多的\n\n      /* 返回值类型  */  只关注返回值类型本身\n      // 对象类型  成员多的可以赋值给成员少的\n      type F1 = () => {name:string}\n      type F2 = () => {name:string; age:number}\n      let f1:F1\n      let f2:F2\n      f1 = f2  // 可以\n\n      // 原始类型   返回的类型相同就可以兼容\n      type F1 = () => string\n      type F2 = () => string\n      let f1:F1\n      let f2:F2\n      f1 = f2 // 可以\n      f2 = f1 // 可以\n\n      /* 交叉类型 & */  功能类似于接口继承（extends），用于组合多个类型为1个类型（常用于对象类型）\n      interface Person { name: string}\n      interface Contact { phone: string}\n      type PersonDetail = Person & Contact\n\n      let obj:PersonDetail = {\n        name: 'abc',\n        phone: '123'\n      }\n\n      /* 泛型 */  泛型是可以在保证类型安全前提下，让函数等与多种类型一起工作，从而实现复用，常用于：函数、接口、class中。\n      function id(value: number):number {return value}\n      // 比如 id（10） 调用以上函数就会直接返回10本身，但是该函数只接受数值类型，无法用于其他类型。为了让函数能够接受任意类型，可以将参数类型改为any\n      function id(value: any):any {return value} // 但是这样就失去了ts的类型保护\n\n      // 泛型在保证类型安全（不丢失类型信息)的同时，可以让函数等于多种不同类型一起工作，灵活可复用\n\n      // 创建泛型函数\n      function id< Type>(value: Type):Type {return value}\n      // 调用\n      let num = id< number>(10)  // num = 10\n      let str = id< string>('a')  // str = 'a'\n      let num = id(100)  // 也是可以的 类型可以省略\n\n      // 类型变量Type 是一种特殊类型的变量，他处理类型而不是值，相当于一个类型容器，捕获用户提供的类型，因为Type是类型，因此可以将其作为函数参数和返回值类型， Type可以是任意合法的变量名称\n\n      /* 泛型约束 */\n      function id< Type>(value: Type): Type{\n        log(value.length)  // 报错\n        return value\n      }\n      // 因为Type可以代表任意类型，无法保证一定存在length属性，比如数字就没有长度，此时就需要为泛型添加约束。\n\n      // 指定更加具体的类型 [] 只要是数组就一定含有length属性\n      function id< Type>(value: Type[]): Type[] {\n        console.log(value.length)  // 可以\n        return value\n      }\n      id([1,2,3])\n\n      /* 通过extends为泛型添加约束 */\n      interface Length {length:number}\n      function id< Type extends Length>(value: Type): Type {\n        console.log(value.length)\n        return value\n      }\n      id('123') // 可以\n      id([1,2,3]) // 可以\n      id({length:10}) // 可以  只要有length属性就行\n\n      /* 多个泛型类型变量之间的约束  keyof */\n      function id< Type, Key extends keyof Type>(obj:Type, key:Key) {\n        return obj[key]\n      }\n      let per = {name:'abc',age:10}\n      id(per,'name')\n\n      // keyof 关键字接受一个对象类型，生成其键名称的联合类型\n      // 示例中 keyof Type 实际上获取的是per对象里所有key的联合类型，也就是 'name'|'age'\n      // 类型变量Key受Type约束，可以理解为Key只能是Type所有键中的任意一个，或者说只能访问对象中存在的属性名称\n\n      /* 泛型接口 */  接口也是可以配合泛型来使用，增加灵活性和复用性\n      interface func< Type> {\n        id: (value: Type) => Type,\n        ids:()=> Type[],\n      }\n      let obj: func< string> = {\n        id(value) {\n          return value\n        },\n        ids() {\n          return ['1']\n        }\n      }\n      console.log(obj.id('123'));\n      console.log(obj.ids());\n      // 在接口名称后面添加< 类型变量>，那么这个接口就成了泛型接口。 接口中所有成员都可以使用类型变量、 使用泛型接口时需要指定具体的类型（比如此时的 func< string>）\n\n      /* 泛型类 */  class类也可以配合泛型来使用\n      class GenericNumber< Type> {\n        value: Type\n        add: (x:Type,y:Type)=> Type\n      }\n      const my = new GenericNumber< number>()\n      my.value = 10\n      // 在class名称后面添加< 类型变量>，这个类就变成了泛型类。\n\n      /* 泛型工具类型 */  Ts里内置了一些常用的工具类型，来简化一些ts中的操作\n\n      /* Partial< Type> */  用来构造一个类型，将Type的所有属性设置为可选\n      interface Props {\n        id: string\n        children: number[]\n      }\n      type PartialProps = Partial< Props>\n      // 构造出来的新类型PartialProps 结构和 Props相同，并且所有属性都是可选的\n      let props:PartialProps = {id:'1',children:[]}\n      props.id='2'\n\n      /* Readonly< Type> */  用来构造一个类型，将Type的所有属性设置为readonly只读\n      interface Props {\n        id: string\n        children: number[]\n      }\n      type ReadonlyProps = Readonly< Props>\n      // 构造出来的新类型PartialProps 结构和 Props相同，但所有属性都是只读的\n      let props:ReadonlyProps = {id:'1',children:[]}\n      props.id='2' // 报错 因为是只读的\n\n      /* Record< Keys,Type> */  构造一个对象类型，属性键为keys,属性类型为Type\n      type RecordObj = Record<'a' | 'b' | 'c', string[]>\n      let obj: RecordObj = {\n        a: ['a'],\n        b: ['b'],\n        c: ['c']\n      }\n      // Record工具类型有两个类型变量，1表示对象里有哪些属性，2表示对象里的属性类型\n\n      /* 索引签名类型 [] */  当无法确定对象中有哪些属性（或者说对象中可以出现任意多个属性）此时 就用到索引签名类型了\n      interface AnyObj {\n        [key:string]: any\n      }\n      let obj:AnyObj = {\n          a:'1',\n          b:2\n      }\n      // 使用[key:string]来约束该接口中允许出现的属性名称，表示只要是string类型的属性名称 都可以出现在对象中\n      // 这样对象obj中就可以出现任意多个属性\n      // key只是一个占位符，可以替换成任意合法的变量名称\n      // 注意：js对象中的key是string类型的\n\n      /* 映射类型 - 两种  */  基于一个旧的类型创建新的类型（对象类型），减少重复，提升效率\n\n      /* [key in keys]  根据联合类型创建  */\n      // 比如类型keys和types都有相同的 x y z\n      type keys = 'x' | 'y' | 'z'\n      type types = { x: number, y: number, z: number }\n      // 这样书写没错但x y z重复写了两次，可以用映射类型来简化\n      type keys = 'x' | 'y' | 'z'\n      type types = { [key in keys]: number }\n      // 映射类型是基于索引签名类型的，所以该语法类似于索引签名类型，也使用了[]\n      // key in keys 表示key可以是keys联合类型中的任意一个\n      // 映射类型只能在类型别名中使用，不能在接口中使用\n\n      /* [key in keyof keys] 根据对象类型创建  */\n      type keys = { x: number, y: number, z: number }\n      type types = { [key in keyof keys]: number }\n      let obj: types = {\n        x: 1,\n        y: 2,\n        z: 3\n      }\n\n      /* 索引查询类型  */  用于查询属性的类型\n      // 查询一个\n      type keys = { x: number, y: string, z: boolean }\n      type typeA = keys['x']\n      let A: typeA = 1\n      let A: typeA = '1' // 报错\n      //keys['a']表示查询类型keys中属性a的类型 ， 所以typeA的类型是number\n\n      // 查询多个\n      type keys = { x: number, y: string, z: boolean }\n      // 两种方式\n      type typeA = keys['x'|'y']  // number | string\n      type typeA = keys[keyof keys]  // number | string | boolean\n    ")]),n._v("\n  ")])}],o=t("5530"),a=t("2f62"),i={components:{},data:function(){return{}},computed:Object(o["a"])({},Object(a["b"])(["theme"])),created:function(){},mounted:function(){},methods:{}},l=i,y=(t("08a5"),t("2877")),u=Object(y["a"])(l,r,s,!1,null,"339f002e",null);e["default"]=u.exports},ac62:function(n,e,t){}}]);
(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-26870bb2"],{"2ac8":function(e,n,t){"use strict";t.r(n);var a=function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"content",class:{contentTheme:e.theme}},[t("div",{staticClass:"synopsis"},[e._v("简介")]),t("div",{staticClass:"synopsisBox"},[e._v(" echarts图表饼图3D立体效果 ")]),t("div",{staticClass:"br"}),t("h3",{staticStyle:{margin:"20px 0"}},[e._v("1. npm下载包")]),e._m(0),t("h3",{staticStyle:{margin:"20px 0"}},[e._v("2. 项目中引入")]),e._m(1),t("h3",{staticStyle:{margin:"20px 0"}},[e._v("3. vue页面封装")]),e._m(2)])},i=[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("pre",{staticClass:"pre"},[e._v("    "),t("code",{staticClass:"code"},[e._v("\n      npm install echarts\n      npm install echarts-gl\n    ")]),e._v("\n  ")])},function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("pre",{staticClass:"pre"},[e._v("    "),t("code",{staticClass:"code"},[e._v("\n      import 'echarts-gl'\n      import * as echarts from 'echarts';\n    ")]),e._v("\n  ")])},function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("pre",{staticClass:"pre"},[e._v("    "),t("code",{staticClass:"code"},[e._v("\n      "),t("code",[e._v("<")]),e._v("template>\n        "),t("code",[e._v("<")]),e._v('div ref="pie3d" style="width: 100%; height: 100%; z-index: 9" />\n      '),t("code",[e._v("<")]),e._v("/template>\n      "),t("code",[e._v("<")]),e._v("script>\n      import 'echarts-gl'\n      import * as echarts from 'echarts'\n      export default {\n        data() {\n          return {\n            optionData: [\n              {\n                name: '监控',\n                value: 0,\n                itemStyle: {\n                color: '#00b2ff',\n                  opacity: '1'\n                }\n              },\n              {\n                name: '水肥机',\n                value: 0,\n                itemStyle: {\n                  color: '#8aef48',\n                  opacity: '1'\n                }\n              },\n              {\n                name: '墒情站',\n                value: 0,\n                itemStyle: {\n                  color: '#f0907f',\n                  opacity: '1'\n                }\n              },\n              {\n                name: '气象',\n                value: 0,\n                itemStyle: {\n                  color: '#faa448',\n                  opacity: '1'\n                }\n              },\n              {\n                name: '增氧机',\n                value: 0,\n                itemStyle: {\n                  color: '#ffdc6c',\n                  opacity: '1'\n                }\n              },\n              {\n                name: '溶氧监测',\n                value: 0,\n                itemStyle: {\n                  color: '#00b2ff',\n                  opacity: '1'\n                }\n              }\n            ],\n            option: null\n          }\n        },\n        mounted() {\n          this.myChart = echarts.init(this.$refs.pie3d)\n          this.init()\n        },\n        methods: {\n          //初始化构建\n          init() {\n            // 数据渲染\n            this.getDate()\n          },\n          getDate() {\n            // 传入数据生成 option ; getPie3D(数据，透明的空心占比（调节中间空心范围的0就是普通饼1就很镂空）)\n            this.option = this.getPie3D(this.optionData, 0.75)\n            //将配置项设置进去\n            this.myChart.setOption(this.option)\n            //鼠标移动上去特效效果\n            this.bindListen(this.myChart)\n          },\n          // 监听鼠标事件，实现饼图选中效果（单选），近似实现高亮（放大）效果。\n          bindListen(myChart) {\n            const that = this\n            let selectedIndex = ''\n            let hoveredIndex = ''\n            // 监听点击事件，实现选中效果（单选）\n            myChart.on('click', function (params) {\n              // 从 option.series 中读取重新渲染扇形所需的参数，将是否选中取反。\n              const isSelected = !that.option.series[params.seriesIndex].pieStatus.selected\n              const isHovered = that.option.series[params.seriesIndex].pieStatus.hovered\n              const k = that.option.series[params.seriesIndex].pieStatus.k\n              const startRatio = that.option.series[params.seriesIndex].pieData.startRatio\n              const endRatio = that.option.series[params.seriesIndex].pieData.endRatio\n              // 如果之前选中过其他扇形，将其取消选中（对 option 更新）\n              if (selectedIndex !== '' && selectedIndex !== params.seriesIndex) {\n                that.option.series[selectedIndex].parametricEquation = that.getParametricEquation(\n                  that.option.series[selectedIndex].pieData.startRatio,\n                  that.option.series[selectedIndex].pieData.endRatio,\n                  false,\n                  false,\n                  k,\n                  that.option.series[selectedIndex].pieData.value\n                )\n                that.option.series[selectedIndex].pieStatus.selected = false\n              }\n              // 对当前点击的扇形，执行选中/取消选中操作（对 option 更新）\n              that.option.series[params.seriesIndex].parametricEquation = that.getParametricEquation(\n                startRatio,\n                endRatio,\n                isSelected,\n                isHovered,\n                k,\n                that.option.series[params.seriesIndex].pieData.value\n              )\n              that.option.series[params.seriesIndex].pieStatus.selected = isSelected\n              // 如果本次是选中操作，记录上次选中的扇形对应的系列号 seriesIndex\n              isSelected ? (selectedIndex = params.seriesIndex) : null\n              // 使用更新后的 option，渲染图表\n              myChart.setOption(that.option)\n            })\n            // 监听 mouseover，近似实现高亮（放大）效果\n            myChart.on('mouseover', function (params) {\n              // 准备重新渲染扇形所需的参数\n              let isSelected\n              let isHovered\n              let startRatio\n              let endRatio\n              let k\n              // 如果触发 mouseover 的扇形当前已高亮，则不做操作\n              if (hoveredIndex === params.seriesIndex) {\n                return\n                // 否则进行高亮及必要的取消高亮操作\n              } else {\n                // 如果当前有高亮的扇形，取消其高亮状态（对 option 更新）\n                if (hoveredIndex !== '') {\n                  // 从 option.series 中读取重新渲染扇形所需的参数，将是否高亮设置为 false。\n                  isSelected = that.option.series[hoveredIndex].pieStatus.selected\n                  isHovered = false\n                  startRatio = that.option.series[hoveredIndex].pieData.startRatio\n                  endRatio = that.option.series[hoveredIndex].pieData.endRatio\n                  k = that.option.series[hoveredIndex].pieStatus.k\n                  // 对当前点击的扇形，执行取消高亮操作（对 option 更新）\n                  that.option.series[hoveredIndex].parametricEquation = that.getParametricEquation(\n                    startRatio,\n                    endRatio,\n                    isSelected,\n                    isHovered,\n                    k,\n                    that.option.series[hoveredIndex].pieData.value\n                  )\n                  that.option.series[hoveredIndex].pieStatus.hovered = isHovered\n                  // 将此前记录的上次选中的扇形对应的系列号 seriesIndex 清空\n                  hoveredIndex = ''\n                }\n                // 如果触发 mouseover 的扇形不是透明圆环，将其高亮（对 option 更新）\n                if (params.seriesName !== 'mouseoutSeries' && params.seriesName !== 'pie2d') {\n                  // 从 option.series 中读取重新渲染扇形所需的参数，将是否高亮设置为 true。\n                  isSelected = that.option.series[params.seriesIndex].pieStatus.selected\n                  isHovered = true\n                  startRatio = that.option.series[params.seriesIndex].pieData.startRatio\n                  endRatio = that.option.series[params.seriesIndex].pieData.endRatio\n                  k = that.option.series[params.seriesIndex].pieStatus.k\n                  // 对当前点击的扇形，执行高亮操作（对 option 更新）\n                  that.option.series[params.seriesIndex].parametricEquation = that.getParametricEquation(\n                    startRatio,\n                    endRatio,\n                    isSelected,\n                    isHovered,\n                    k,\n                    that.option.series[params.seriesIndex].pieData.value + 5\n                  )\n                  that.option.series[params.seriesIndex].pieStatus.hovered = isHovered\n                  // 记录上次高亮的扇形对应的系列号 seriesIndex\n                  hoveredIndex = params.seriesIndex\n                }\n                // 使用更新后的 option，渲染图表\n                myChart.setOption(that.option)\n              }\n            })\n            // 修正取消高亮失败的 bug\n            myChart.on('globalout', function () {\n              // 准备重新渲染扇形所需的参数\n              let isSelected\n              let isHovered\n              let startRatio\n              let endRatio\n              let k\n              if (hoveredIndex !== '') {\n                // 从 option.series 中读取重新渲染扇形所需的参数，将是否高亮设置为 true。\n                isSelected = that.option.series[hoveredIndex].pieStatus.selected\n                isHovered = false\n                k = that.option.series[hoveredIndex].pieStatus.k\n                startRatio = that.option.series[hoveredIndex].pieData.startRatio\n                endRatio = that.option.series[hoveredIndex].pieData.endRatio\n                // 对当前点击的扇形，执行取消高亮操作（对 option 更新）\n                that.option.series[hoveredIndex].parametricEquation = that.getParametricEquation(\n                  startRatio,\n                  endRatio,\n                  isSelected,\n                  isHovered,\n                  k,\n                  that.option.series[hoveredIndex].pieData.value\n                )\n                that.option.series[hoveredIndex].pieStatus.hovered = isHovered\n                // 将此前记录的上次选中的扇形对应的系列号 seriesIndex 清空\n                hoveredIndex = ''\n              }\n              // 使用更新后的 option，渲染图表\n              myChart.setOption(that.option)\n            })\n          },\n          getPie3D(pieData, internalDiameterRatio) {\n            const that = this\n            const series = []\n            let sumValue = 0\n            let startValue = 0\n            let endValue = 0\n            let legendData = []\n            const k = 1 - internalDiameterRatio\n            pieData.sort((a, b) => {\n              return b.value - a.value\n            })\n            // 为每一个饼图数据，生成一个 series-surface(参数曲面) 配置\n            for (let i = 0; i < pieData.length; i++) {\n              sumValue += pieData[i].value\n              const seriesItem = {\n                //系统名称\n                name: typeof pieData[i].name === 'undefined' ? `series${i}` : pieData[i].name,\n                type: 'surface',\n                //是否为参数曲面（是）\n                parametric: true,\n                //曲面图网格线（否）上面一根一根的\n                wireframe: {\n                  show: false\n                },\n                pieData: pieData[i],\n                pieStatus: {\n                  selected: false,\n                  hovered: false,\n                  k: k\n                }\n              }\n              //曲面的颜色、不透明度等样式。\n              if (typeof pieData[i].itemStyle !== 'undefined') {\n                const itemStyle = {}\n                typeof pieData[i].itemStyle.color !== 'undefined'\n                  ? (itemStyle.color = pieData[i].itemStyle.color)\n                  : null\n                typeof pieData[i].itemStyle.opacity !== 'undefined'\n                  ? (itemStyle.opacity = pieData[i].itemStyle.opacity)\n                  : null\n                seriesItem.itemStyle = itemStyle\n              }\n              series.push(seriesItem)\n            }\n            // 使用上一次遍历时，计算出的数据和 sumValue，调用 getParametricEquation 函数，\n            // 向每个 series-surface 传入不同的参数方程 series-surface.parametricEquation，也就是实现每一个扇形。\n            legendData = []\n\n            for (let i = 0; i < series.length; i++) {\n              endValue = startValue + series[i].pieData.value\n              series[i].pieData.startRatio = startValue / sumValue\n              series[i].pieData.endRatio = endValue / sumValue\n              series[i].parametricEquation = this.getParametricEquation(\n                series[i].pieData.startRatio,\n                series[i].pieData.endRatio,\n                false,\n                false,\n                k,\n                series[i].pieData.value\n              )\n              startValue = endValue\n              const bfb = that.fomatFloat(series[i].pieData.value / sumValue, 4)\n              legendData.push({\n                name: series[i].name,\n                value: bfb\n              })\n            }\n            //(第二个参数可以设置你这个环形的高低程度)\n            const boxHeight = this.getHeight3D(series, 13) //通过传参设定3d饼/环的高度\n            // 准备待返回的配置项，把准备好的 legendData、series 传入。\n            const option = {\n              //这个可以变形\n              xAxis3D: {\n                min: -1,\n                max: 1\n              },\n              yAxis3D: {\n                min: -1,\n                max: 1\n              },\n              zAxis3D: {\n                min: -1,\n                max: 1\n              },\n              //此处是修改样式的重点\n              grid3D: {\n                show: false,\n                boxHeight: boxHeight, //圆环的高度\n                //这是饼图的位置\n                left: '0%',\n                top: '-10%',\n                viewControl: {\n                  //3d效果可以放大、旋转等，请自己去查看官方配置\n                  alpha: 25, //角度(这个很重要 调节角度的)\n                  distance: 200, //调整视角到主体的距离，类似调整zoom(这是整体大小)\n                  rotateSensitivity: 1, //设置为0无法旋转\n                  zoomSensitivity: 0, //设置为0无法缩放\n                  panSensitivity: 0, //设置为0无法平移\n                  autoRotate: true //自动旋转\n                }\n              },\n              series: series\n            }\n            return option\n          },\n          getHeight3D(series, height) {\n            series.sort((a, b) => {\n              return b.pieData.value - a.pieData.value\n            })\n            return (height * 25) / series[0].pieData.value\n          },\n          getParametricEquation(startRatio, endRatio, isSelected, isHovered, k, h) {\n            // 计算\n            const midRatio = (startRatio + endRatio) / 2\n            const startRadian = startRatio * Math.PI * 2\n            const endRadian = endRatio * Math.PI * 2\n            const midRadian = midRatio * Math.PI * 2\n            // 如果只有一个扇形，则不实现选中效果。\n            if (startRatio === 0 && endRatio === 1) {\n              isSelected = false\n            }\n            // 通过扇形内径/外径的值，换算出辅助参数 k（默认值 1/3）\n            k = typeof k !== 'undefined' ? k : 1 / 3\n            // 计算选中效果分别在 x 轴、y 轴方向上的位移（未选中，则位移均为 0）\n            const offsetX = isSelected ? Math.cos(midRadian) * 0.1 : 0\n            const offsetY = isSelected ? Math.sin(midRadian) * 0.1 : 0\n            // 计算高亮效果的放大比例（未高亮，则比例为 1）\n            const hoverRate = isHovered ? 1.05 : 1\n            // 返回曲面参数方程\n            return {\n              u: {\n                min: -Math.PI,\n                max: Math.PI * 3,\n                step: Math.PI / 32\n              },\n              v: {\n                min: 0,\n                max: Math.PI * 2,\n                step: Math.PI / 20\n              },\n              x: function (u, v) {\n                if (u < startRadian) {\n                  return offsetX + Math.cos(startRadian) * (1 + Math.cos(v) * k) * hoverRate\n                }\n                if (u > endRadian) {\n                  return offsetX + Math.cos(endRadian) * (1 + Math.cos(v) * k) * hoverRate\n                }\n                return offsetX + Math.cos(u) * (1 + Math.cos(v) * k) * hoverRate\n              },\n              y: function (u, v) {\n                if (u < startRadian) {\n                  return offsetY + Math.sin(startRadian) * (1 + Math.cos(v) * k) * hoverRate\n                }\n                if (u > endRadian) {\n                  return offsetY + Math.sin(endRadian) * (1 + Math.cos(v) * k) * hoverRate\n                }\n                return offsetY + Math.sin(u) * (1 + Math.cos(v) * k) * hoverRate\n              },\n              z: function (u, v) {\n                if (u < -Math.PI * 0.5) {\n                  return Math.sin(u)\n                }\n                if (u > Math.PI * 2.5) {\n                  return Math.sin(u) * h * 0.1\n                }\n                return Math.sin(v) > 0 ? 1 * h * 0.1 : -1\n              }\n            }\n          },\n          fomatFloat(num, n) {\n            let f = parseFloat(num)\n            if (isNaN(f)) {\n              return false\n            }\n            f = Math.round(num * Math.pow(10, n)) / Math.pow(10, n) // n 幂\n            let s = f.toString()\n            let rs = s.indexOf('.')\n            //判定如果是整数，增加小数点再补0\n            if (rs < 0) {\n              rs = s.length\n              s += '.'\n            }\n            while (s.length <= rs + n) {\n              s += '0'\n            }\n            return s\n          }\n        }\n      }\n      "),t("code",[e._v("<")]),e._v("/script>\n    ")]),e._v("\n  ")])}],s=t("5530"),o=t("2f62"),r={components:{},data:function(){return{}},computed:Object(s["a"])({},Object(o["b"])(["theme"])),created:function(){},mounted:function(){},methods:{}},d=r,p=(t("82fc"),t("2877")),l=Object(p["a"])(d,a,i,!1,null,"61849326",null);n["default"]=l.exports},"82fc":function(e,n,t){"use strict";t("f0d3")},f0d3:function(e,n,t){}}]);